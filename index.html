<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled 3D Particles + Gemini AI</title>
    
    <!-- MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        
        #ui-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
            width: 90%;
            align-items: center;
        }

        .controls-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 1px;
            white-space: nowrap;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        .btn.active {
            background: rgba(0, 255, 150, 0.3);
            border-color: #00ff96;
            color: #00ff96;
        }
        
        .btn.toggle-active {
            background: rgba(255, 170, 0, 0.3);
            border-color: #ffaa00;
            color: #ffaa00;
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.4);
        }

        /* Color Theme Swatches */
        .theme-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
            cursor: pointer;
            transition: transform 0.2s;
        }
        .theme-btn:hover { transform: scale(1.2); }
        .theme-btn.active { border-color: white; transform: scale(1.1); box-shadow: 0 0 10px white; }

        /* AI Input Styles */
        .ai-group {
            display: flex;
            gap: 5px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-left: 10px;
        }

        #ai-input {
            background: transparent;
            border: none;
            color: white;
            padding: 5px 15px;
            outline: none;
            width: 150px;
            font-family: inherit;
        }
        
        #ai-btn {
            background: linear-gradient(135deg, #6e8efb, #a777e3);
            border: none;
            font-weight: bold;
        }

        #ai-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        /* HUD Sidebar */
        #hud-sidebar {
            position: absolute;
            right: 10px;
            top: 10px;
            bottom: 10px;
            width: 260px; /* Increased width for larger items */
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            pointer-events: none; 
            z-index: 20;
            padding-right: 5px; 
        }

        #hud-sidebar::-webkit-scrollbar { width: 4px; }
        #hud-sidebar::-webkit-scrollbar-track { background: rgba(255,255,255,0.1); }
        #hud-sidebar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 2px; }

        .hud-item {
            position: relative;
            width: 240px; /* Increased Size */
            height: 180px; /* Increased Size */
            flex-shrink: 0;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            pointer-events: auto; 
            overflow: hidden;
        }

        .hud-canvas, .hud-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Mirror Specific Elements (Self-View) */
        .hud-video, #tracking-view, #skeleton-view {
            transform: scaleX(-1);
        }
        
        /* Do NOT Mirror Data/Text elements */
        #radar-view, #confidence-view {
            transform: none;
        }

        .hud-caption {
            position: absolute;
            bottom: 4px;
            right: 6px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            letter-spacing: 1px;
            background: rgba(0,0,0,0.6);
            padding: 2px 4px;
            border-radius: 4px;
            pointer-events: none;
        }

        /* Specific HUD Styles */
        #tracking-view { border-color: rgba(0, 255, 150, 0.5); }
        #skeleton-view { border-color: rgba(255, 50, 50, 0.5); }
        #radar-view { border-color: rgba(0, 200, 255, 0.5); background: rgba(0, 20, 40, 0.9); }
        #confidence-view { border-color: rgba(200, 0, 255, 0.5); background: rgba(20, 0, 40, 0.9); }

        /* Stats Panel */
        #stats-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid rgba(0, 255, 150, 0.3);
            padding: 15px;
            border-radius: 12px;
            color: #00ff96;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            pointer-events: none;
            z-index: 10;
            display: none;
            text-align: left;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            min-width: 180px;
        }
        .stat-row { display: flex; justify-content: space-between; gap: 15px; margin-bottom: 6px; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 2px;}
        .stat-row:last-child { border-bottom: none; margin-bottom: 0; }
        .stat-label { color: rgba(255,255,255,0.7); }
        .stat-value { font-weight: bold; }

        /* Instruction Panel */
        #instructions {
            position: absolute;
            top: 60px;
            left: 20px;
            width: 200px;
            background: rgba(0, 20, 40, 0.7);
            border: 1px solid rgba(0, 255, 150, 0.3);
            border-radius: 12px;
            padding: 15px;
            color: #fff;
            font-size: 13px;
            pointer-events: none;
            backdrop-filter: blur(4px);
            z-index: 8;
        }

        #instructions h3 {
            margin: 0 0 10px 0;
            color: #00ff96;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 5px;
        }

        .gesture-item { display: flex; align-items: center; margin-bottom: 8px; }
        .gesture-icon { font-size: 18px; margin-right: 10px; width: 25px; text-align: center; }
        .gesture-desc { color: rgba(255,255,255,0.8); }

        #motion-canvas { display: none; }
        /* Lyrics / Music Mode Overlay */
        #lyrics-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 30;
            text-align: center;
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #lyrics-word {
            font-size: 48px;
            font-weight: 700;
            text-shadow: 0 6px 24px rgba(0,0,0,0.8), 0 2px 6px rgba(0,0,0,0.6);
            background: rgba(0,0,0,0.35);
            padding: 12px 20px;
            border-radius: 12px;
            display: inline-block;
            pointer-events: none;
        }
        /* Debug Panel Styles */
        #debug-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 360px;
            background: rgba(10,10,10,0.75);
            border: 1px solid rgba(255,255,255,0.08);
            color: #fff;
            padding: 10px;
            border-radius: 8px;
            z-index: 60;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            backdrop-filter: blur(6px);
        }
        #debug-panel button { background: rgba(255,255,255,0.06); color: #fff; border: 1px solid rgba(255,255,255,0.08); border-radius:4px; cursor:pointer }
    </style>
</head>
<body>

    <div id="status">Waiting for camera...</div>
    <!-- Lyrics Fetch Debug Panel -->
    <div id="debug-panel" style="display:block;">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
            <strong style="font-size:12px;">Lyrics Debug</strong>
            <div>
                <button id="debug-toggle" style="font-size:12px;padding:4px 8px;">Hide</button>
                <button id="debug-clear" style="font-size:12px;padding:4px 8px;margin-left:6px;">Clear</button>
            </div>
        </div>
        <div style="margin-top:8px;font-size:12px;line-height:1.3;">
            <div><strong>Request URL:</strong> <span id="dbg-url">-</span></div>
            <div><strong>HTTP Status:</strong> <span id="dbg-status">-</span></div>
            <div style="margin-top:6px;"><strong>Raw Response:</strong></div>
            <pre id="dbg-body" style="white-space:pre-wrap;max-height:180px;overflow:auto;background:rgba(0,0,0,0.6);padding:8px;border-radius:6px;margin-top:4px;font-size:12px;color:#dcdcdc;">-</pre>
        </div>
    </div>

    <!-- Instruction Panel -->
    <div id="instructions">
        <h3>Gesture Guide</h3>
        <div class="gesture-item"><span class="gesture-icon">üñê</span><span class="gesture-desc"><strong>Open:</strong> Scatter</span></div>
        <div class="gesture-item"><span class="gesture-icon">‚úä</span><span class="gesture-desc"><strong>Fist:</strong> Gravity</span></div>
        <div class="gesture-item"><span class="gesture-icon">‚úåÔ∏è</span><span class="gesture-desc"><strong>Victory:</strong> Vortex</span></div>
        <div class="gesture-item"><span class="gesture-icon">üëå</span><span class="gesture-desc"><strong>Pinch:</strong> Rotate / Grab</span></div>
        <div class="gesture-item"><span class="gesture-icon">üôå</span><span class="gesture-desc"><strong>2 Hands:</strong> Zoom</span></div>
    </div>

    <!-- Performance Stats Panel -->
    <div id="stats-panel">
        <div class="stat-row"><span class="stat-label">FPS:</span><span id="stat-fps" class="stat-value">--</span></div>
        <div class="stat-row"><span class="stat-label">Render Time:</span><span id="stat-ms" class="stat-value">--</span></div>
        <div class="stat-row"><span class="stat-label">Memory:</span><span id="stat-mem" class="stat-value">--</span></div>
        <div class="stat-row"><span class="stat-label">Entities:</span><span id="stat-count" class="stat-value">--</span></div>
        <div class="stat-row"><span class="stat-label">Resolution:</span><span id="stat-res" class="stat-value">--</span></div>
        <div class="stat-row"><span class="stat-label">Active Hands:</span><span id="stat-hands" class="stat-value">0</span></div>
    </div>

    <!-- HUD Sidebar (Scrollable) -->
    <div id="hud-sidebar">
        <!-- 1. Raw Feed -->
        <div class="hud-item">
            <video id="webcam-preview" class="hud-video" autoplay playsinline muted></video>
            <div class="hud-caption">Raw Feed</div>
        </div>
        <!-- 2. Motion Grid -->
        <div class="hud-item">
            <canvas id="tracking-view" class="hud-canvas"></canvas>
            <div class="hud-caption">Motion Grid</div>
        </div>
        <!-- 3. Skeletal Tracking -->
        <div class="hud-item">
            <canvas id="skeleton-view" class="hud-canvas"></canvas>
            <div class="hud-caption">Skeleton</div>
        </div>
        <!-- 4. 3D Radar -->
        <div class="hud-item">
            <canvas id="radar-view" class="hud-canvas"></canvas>
            <div class="hud-caption">3D Radar</div>
        </div>
        <!-- 5. Confidence -->
        <div class="hud-item">
            <canvas id="confidence-view" class="hud-canvas"></canvas>
            <div class="hud-caption">AI Confidence</div>
        </div>
    </div>
    
    <canvas id="motion-canvas"></canvas>

    <div id="ui-container">
        <!-- Visual Style Selector -->
        <div class="controls-row">
            <button id="vis-points" class="btn active" onclick="setVisual('points')">‚ú® Points</button>
            <button id="vis-cubes" class="btn" onclick="setVisual('cubes')">üßä Cubes</button>
            <button id="vis-shards" class="btn" onclick="setVisual('shards')">üíé Shards</button>
        </div>

        <!-- Main Controls -->
        <div class="controls-row">
            <button class="btn active" onclick="setShape('sphere')">Sphere</button>
            <button class="btn" onclick="setShape('heart')">Heart</button>
            <button class="btn" onclick="setShape('saturn')">Saturn</button>
            <button class="btn" onclick="setShape('helix')">Helix</button>
            
            <button id="btn-toy" class="btn" onclick="toggleObjects()">üî≤ Objects</button>
            <button id="btn-trails" class="btn" onclick="toggleTrails()">üé® Trails</button>
            <button id="btn-fluid" class="btn" onclick="toggleFluid()">üåä Fluid</button>
            <button id="btn-stats" class="btn" onclick="toggleStats()">üìä Stats</button>

            <div class="ai-group">
                <input id="music-artist" type="text" placeholder="Artist" style="background:transparent;border:none;color:white;padding:6px 10px;outline:none;" />
                <input id="music-title" type="text" placeholder="Title" style="background:transparent;border:none;color:white;padding:6px 10px;outline:none;" />
                <button id="fetch-lyrics" class="btn" onclick="fetchLyrics()">üéµ Fetch</button>
                <button id="play-lyrics" class="btn" onclick="toggleLyricsPlay()" disabled>‚ñ∂ Play</button>
                <div style="display:flex;align-items:center;gap:8px;margin-left:8px;">
                    <label style="color:rgba(255,255,255,0.65);font-size:12px;margin-right:4px;">WPM</label>
                    <input id="lyrics-wpm" type="range" min="60" max="400" value="180" style="width:100px;" oninput="document.getElementById('wpm-val').innerText=this.value" />
                    <span id="wpm-val" style="color:rgba(255,255,255,0.8);">180</span>
                </div>
            </div>
        </div>

        <!-- Theme Selector -->
        <div class="controls-row">
            <div class="theme-btn active" style="background: linear-gradient(135deg, #00ffff, #ff00ff);" onclick="setTheme('default')" title="Default"></div>
            <div class="theme-btn" style="background: linear-gradient(135deg, #ff0000, #ffff00);" onclick="setTheme('fire')" title="Fire"></div>
            <div class="theme-btn" style="background: linear-gradient(135deg, #00ffff, #ffffff);" onclick="setTheme('ice')" title="Ice"></div>
            <div class="theme-btn" style="background: linear-gradient(135deg, #00ff00, #004400);" onclick="setTheme('matrix')" title="Matrix"></div>
            <div class="theme-btn" style="background: linear-gradient(135deg, #ff00cc, #3300ff);" onclick="setTheme('cyber')" title="Cyber"></div>
        </div>
    </div>

    <!-- Lyrics Overlay (Music Mode) -->
    <div id="lyrics-overlay" aria-live="polite">
        <span id="lyrics-word" style="display:none;"></span>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Post-Processing Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/AfterimageShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/AfterimagePass.js"></script>

    <script>
        // --- Configuration ---
        const PARTICLE_COUNT = 15000;
        const PARTICLE_SIZE = 0.15;
        const CAM_FOV = 75;
        const apiKey = ""; 
        const HUD_WIDTH = 240;
        const HUD_HEIGHT = 180;
        
        // --- Globals ---
        let scene, camera, renderer, composer;
        let particles, geometry, material;
        let positions, targets, colors, velocities;
        let clock = new THREE.Clock();
        
        // Stats
        let statsVisible = false;
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let lastFpsUpdate = 0;
        
        // Radar
        let radarSweepAngle = 0;

        // Input Stability
        let lastInputTime = 0; // NEW: To track when we last saw a hand

        // Visual Styles
        let currentVisual = 'points';
        let meshCubes, meshShards;
        let dummy = new THREE.Object3D(); 

        // Physics & Objects
        let floatingObjects = []; // Array of objects
        let isObjectsActive = false; // Renamed to ensure consistency
        let isToyActive = false; // Kept for backwards compatibility if needed, but we use isObjectsActive mostly
        let afterimagePass;
        let isTrailsActive = false;
        let isFluidActive = false;
        let currentTheme = 'default';
        let targetColors = new Float32Array(PARTICLE_COUNT * 3);

        // Motion Tracking & HUD Canvas Refs
        const video = document.getElementById('webcam-preview');
        const motionCanvas = document.getElementById('motion-canvas');
        const motionCtx = motionCanvas.getContext('2d', { willReadFrequently: true });
        const trackingCanvas = document.getElementById('tracking-view');
        const trackingCtx = trackingCanvas.getContext('2d');
        const skeletonCanvas = document.getElementById('skeleton-view');
        const skeletonCtx = skeletonCanvas.getContext('2d');
        
        // New HUD Refs
        const radarCanvas = document.getElementById('radar-view');
        const radarCtx = radarCanvas.getContext('2d');
        const confidenceCanvas = document.getElementById('confidence-view');
        const confidenceCtx = confidenceCanvas.getContext('2d');

        let prevFrameData = null;
        let motionX = 0, motionY = 0;
        let isWebcamReady = false;
        let handResults = null;

        // Multi-Hand
        let cursorMeshes = [];
        let pointers = [new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)];
        let handGestures = ['open', 'open']; 
        let activeHandCount = 0;
        let shapeScale = 1.0;
        let previousHandDist = 0;
        let lastPinchPos = null; // For scene rotation
        let handGrabbedObj = [null, null]; // Track which object each hand is holding
        
        const mouse = new THREE.Vector2();
        
        // Confidence State
        let gestureConfidence = [{}, {}];

        let currentShape = 'sphere';
        let customShapeFunction = null; 

        // --- Music Mode: Lyrics playback state ---
        // Documentation:
        // API Endpoint: https://api.lyrics.ovh/v1/{artist}/{title}
        // Request: GET https://api.lyrics.ovh/v1/<url-encoded-artist>/<url-encoded-title>
        // Response: JSON { "lyrics": "...full lyrics text..." }
        // Error handling: The API responds with an error JSON for not found or on failure.
        //   - Network errors are caught and reported via status text.
        //   - If lyrics are not found, the response may contain {"error":"No lyrics found"}.
        //   - We display human-readable messages in #status and disable Play when unavailable.

        let lyricsWords = [];
        let lyricsIndex = 0;
        let lyricsTimer = null;
        let isLyricsPlaying = false;

        // Fetch lyrics from a public, free API (lyrics.ovh)
        async function fetchLyrics() {
            const artist = document.getElementById('music-artist').value.trim();
            const title = document.getElementById('music-title').value.trim();
            const statusEl = document.getElementById('status');
            if (!artist || !title) { statusEl.innerText = 'Enter artist and title.'; return; }

            // Disable controls while fetching
            const fetchBtn = document.getElementById('fetch-lyrics');
            const playBtn = document.getElementById('play-lyrics');
            fetchBtn.disabled = true;
            playBtn.disabled = true;
            statusEl.innerText = 'Fetching lyrics...';
            const url = `https://api.lyrics.ovh/v1/${encodeURIComponent(artist)}/${encodeURIComponent(title)}`;
            try {
                const res = await fetch(url, { method: 'GET' });
                // For debugging: log URL and status
                console.debug('Lyrics fetch', url, res.status);
                // Read raw body for debug panel and parsing
                const rawBody = await res.text();
                updateDebugPanel(url, res.status, rawBody);

                // Try to parse JSON response
                let data = null;
                try { data = JSON.parse(rawBody); } catch (e) { data = null; }

                if (!res.ok) {
                    let message = `HTTP ${res.status}`;
                    if (data && data.error) message = data.error;
                    console.warn('Lyrics fetch failed', { url, status: res.status, body: rawBody });
                    statusEl.innerText = `Lyrics fetch error: ${message}`;
                    playBtn.disabled = true;
                    fetchBtn.disabled = false;
                    return;
                }
                if (!data || !data.lyrics) {
                    console.warn('Lyrics response missing lyrics', { url, data, rawBody });
                    statusEl.innerText = 'No lyrics found.';
                    playBtn.disabled = true;
                    fetchBtn.disabled = false;
                    return;
                }

                // Normalize lyrics: replace CRLF with LF, trim, split into tokens (words & punctuation)
                const txt = data.lyrics.replace(/\r\n/g, '\n').trim();
                // Split keeping line breaks as tokens so we can show them as pauses
                const tokens = txt.split(/(\n)|\s+/).filter(t => t !== undefined && t !== null && t !== '');
                lyricsWords = tokens;
                lyricsIndex = 0;
                statusEl.innerText = `Fetched ${lyricsWords.length} tokens.`;
                playBtn.disabled = false;
                fetchBtn.disabled = false;
                // Show first word as preview
                updateLyricsDisplay();
            } catch (err) {
                statusEl.innerText = 'Network error fetching lyrics. See debug panel/console for details.';
                console.error('Lyrics fetch error', { url, err });
                // Surface error details in the debug panel for easier diagnosis
                try { updateDebugPanel(url, 'FAILED', err.stack || err.message || String(err)); } catch (e) { /* ignore */ }
                playBtn.disabled = true;
                fetchBtn.disabled = false;
            }
        }

        function toggleLyricsPlay() {
            if (isLyricsPlaying) { pauseLyrics(); } else { startLyrics(); }
        }

        function startLyrics() {
            if (!lyricsWords || lyricsWords.length === 0) return;
            isLyricsPlaying = true;
            document.getElementById('play-lyrics').innerText = '‚è∏ Pause';
            // Compute delay from WPM (words per minute). Convert to ms per token.
            const wpm = parseInt(document.getElementById('lyrics-wpm').value || '180', 10);
            const msPerWord = Math.max(20, Math.round(60000 / Math.max(1, wpm)));
            // Clear any existing timer
            clearInterval(lyricsTimer);
            lyricsTimer = setInterval(() => {
                showNextToken();
            }, msPerWord);
        }

        function pauseLyrics() {
            isLyricsPlaying = false;
            document.getElementById('play-lyrics').innerText = '‚ñ∂ Play';
            clearInterval(lyricsTimer);
            lyricsTimer = null;
        }

        function stopLyrics() {
            pauseLyrics();
            lyricsIndex = 0;
            updateLyricsDisplay();
        }

        function showNextToken() {
            if (!lyricsWords || lyricsWords.length === 0) return;
            // Advance index and wrap at end
            lyricsIndex++;
            if (lyricsIndex >= lyricsWords.length) {
                // Stop at end
                stopLyrics();
                document.getElementById('status').innerText = 'Playback finished.';
                return;
            }
            updateLyricsDisplay();
        }

        function updateLyricsDisplay() {
            const display = document.getElementById('lyrics-word');
            if (!lyricsWords || lyricsWords.length === 0) {
                display.style.display = 'none';
                return;
            }
            const token = lyricsWords[lyricsIndex];
            // If token is a newline token ("\n"), show a short empty pause
            if (token === '\n') {
                display.innerText = '';
                display.style.display = 'inline-block';
            } else {
                display.innerText = token;
                display.style.display = 'inline-block';
            }
        }

        // --- Debug panel helpers ---
        function updateDebugPanel(url, status, body) {
            try {
                document.getElementById('dbg-url').innerText = url || '-';
                document.getElementById('dbg-status').innerText = status === undefined ? '-' : status;
                const pretty = (typeof body === 'string') ? body : JSON.stringify(body, null, 2);
                document.getElementById('dbg-body').innerText = pretty ? pretty : '-';
                document.getElementById('debug-panel').style.display = 'block';
            } catch (e) { console.warn('updateDebugPanel error', e); }
        }

        // Hook up debug panel buttons
        (function setupDebugControls(){
            const toggle = document.getElementById('debug-toggle');
            const clear = document.getElementById('debug-clear');
            if (!toggle || !clear) return;
            toggle.addEventListener('click', () => {
                const panel = document.getElementById('debug-panel');
                if (panel.style.display === 'none') { panel.style.display = 'block'; toggle.innerText = 'Hide'; }
                else { panel.style.display = 'none'; toggle.innerText = 'Show'; }
            });
            clear.addEventListener('click', () => {
                document.getElementById('dbg-url').innerText = '-';
                document.getElementById('dbg-status').innerText = '-';
                document.getElementById('dbg-body').innerText = '-';
            });
        })();

        init();
        setupWebcam();
        setupMediaPipe(); 
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(CAM_FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Force 3D canvas to background
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.zIndex = '-1'; 
            
            document.body.appendChild(renderer.domElement);

            // Initialize Floating Objects Pool (Hidden initially)
            initFloatingObjects();

            // Post Processing
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = 1.5; bloomPass.radius = 0.4; bloomPass.threshold = 0.2; 
            afterimagePass = new THREE.AfterimagePass();
            afterimagePass.uniforms["damp"].value = 0.96; 
            afterimagePass.enabled = false; 

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.addPass(afterimagePass);

            // Cursors
            const cursorGeo = new THREE.SphereGeometry(0.5, 16, 16);
            for(let i=0; i<2; i++) {
                const cursorMat = new THREE.MeshBasicMaterial({ color: 0xff3333, transparent: true, opacity: 0.8 });
                const mesh = new THREE.Mesh(cursorGeo, cursorMat);
                mesh.visible = false;
                scene.add(mesh);
                cursorMeshes.push(mesh);
            }

            // Particles
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            targets = new Float32Array(PARTICLE_COUNT * 3); 
            colors = new Float32Array(PARTICLE_COUNT * 3);
            velocities = new Float32Array(PARTICLE_COUNT * 3); 
            const color = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
                velocities[i*3] = velocities[i*3+1] = velocities[i*3+2] = 0;

                const vx = (i / PARTICLE_COUNT);
                color.setHSL(0.5 + vx * 0.2, 0.8, 0.6);
                colors[i * 3] = targetColors[i*3] = color.r;
                colors[i * 3 + 1] = targetColors[i*3+1] = color.g;
                colors[i * 3 + 2] = targetColors[i*3+2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE, vertexColors: true, blending: THREE.AdditiveBlending,
                depthWrite: false, transparent: true, opacity: 0.8, map: createCircleTexture()
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Instanced Meshes
            const cubeGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const cubeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            meshCubes = new THREE.InstancedMesh(cubeGeo, cubeMat, PARTICLE_COUNT);
            meshCubes.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            meshCubes.visible = false;
            scene.add(meshCubes);

            const shardGeo = new THREE.TetrahedronGeometry(0.25);
            const shardMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            meshShards = new THREE.InstancedMesh(shardGeo, shardMat, PARTICLE_COUNT);
            meshShards.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            meshShards.visible = false;
            scene.add(meshShards);

            calculateTargets('sphere');
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
        }

        // --- Floating Objects System ---
        function initFloatingObjects() {
            // Create a few different shapes
            const geometries = [
                new THREE.IcosahedronGeometry(2, 0),
                new THREE.OctahedronGeometry(1.5, 0),
                new THREE.TetrahedronGeometry(1.8, 0),
                new THREE.TorusGeometry(1.2, 0.4, 8, 16),
                new THREE.BoxGeometry(2, 2, 2)
            ];
            
            const colors = [0xffaa00, 0x00ffaa, 0xff00aa, 0x00aaff, 0xaaff00];

            for(let i=0; i<5; i++) {
                const mat = new THREE.MeshBasicMaterial({ 
                    color: colors[i], 
                    wireframe: true, 
                    transparent: true, 
                    opacity: 0.8 
                });
                const mesh = new THREE.Mesh(geometries[i], mat);
                mesh.visible = false;
                scene.add(mesh);
                
                floatingObjects.push({
                    mesh: mesh,
                    velocity: new THREE.Vector3(
                        (Math.random()-0.5)*0.2, 
                        (Math.random()-0.5)*0.2, 
                        (Math.random()-0.5)*0.2
                    ),
                    rotVel: new THREE.Vector3(
                        (Math.random()-0.5)*0.05, 
                        (Math.random()-0.5)*0.05, 
                        (Math.random()-0.5)*0.05
                    ),
                    id: i
                });
            }
        }

        function toggleObjects() {
            isObjectsActive = !isObjectsActive;
            const btn = document.getElementById('btn-toy');
            if(isObjectsActive) btn.classList.add('toggle-active'); else btn.classList.remove('toggle-active');
            
            // Reset positions when activated
            if(isObjectsActive) {
                floatingObjects.forEach((obj, idx) => {
                    obj.mesh.visible = true;
                    obj.mesh.position.set(
                        (Math.random()-0.5)*20, 
                        (Math.random()-0.5)*15, 
                        (Math.random()-0.5)*10
                    );
                    obj.velocity.set((Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2);
                });
            } else {
                floatingObjects.forEach(obj => obj.mesh.visible = false);
            }
        }

        function setVisual(type) {
            currentVisual = type;
            particles.visible = (type === 'points');
            meshCubes.visible = (type === 'cubes');
            meshShards.visible = (type === 'shards');
            document.querySelectorAll('#vis-points, #vis-cubes, #vis-shards').forEach(b => b.classList.remove('active'));
            document.getElementById('vis-' + type).classList.add('active');
        }

        function toggleTrails() {
            isTrailsActive = !isTrailsActive;
            afterimagePass.enabled = isTrailsActive;
            const btn = document.getElementById('btn-trails');
            if(isTrailsActive) btn.classList.add('toggle-active'); else btn.classList.remove('toggle-active');
        }

        function toggleFluid() {
            isFluidActive = !isFluidActive;
            const btn = document.getElementById('btn-fluid');
            if(isFluidActive) btn.classList.add('toggle-active'); else btn.classList.remove('toggle-active');
            if (isFluidActive) {
                for(let i=0; i<PARTICLE_COUNT; i++) {
                    velocities[i*3] = (Math.random()-0.5)*0.5;
                    velocities[i*3+1] = (Math.random()-0.5)*0.5;
                    velocities[i*3+2] = (Math.random()-0.5)*0.5;
                }
            }
        }

        function toggleStats() {
            statsVisible = !statsVisible;
            document.getElementById('stats-panel').style.display = statsVisible ? 'block' : 'none';
            const btn = document.getElementById('btn-stats');
            if(statsVisible) btn.classList.add('toggle-active'); else btn.classList.remove('toggle-active');
        }

        function updateStats(now) {
            if(!statsVisible) { lastFrameTime = now; return; }
            frameCount++;
            if (now - lastFpsUpdate >= 500) {
                const delta = now - lastFpsUpdate;
                const fps = Math.round((frameCount * 1000) / delta);
                const frameTime = (delta / frameCount).toFixed(1);
                document.getElementById('stat-fps').innerText = fps;
                document.getElementById('stat-ms').innerText = frameTime + 'ms';
                document.getElementById('stat-count').innerText = PARTICLE_COUNT;
                document.getElementById('stat-res').innerText = window.innerWidth + 'x' + window.innerHeight;
                document.getElementById('stat-hands').innerText = activeHandCount;
                if (performance && performance.memory) {
                    document.getElementById('stat-mem').innerText = Math.round(performance.memory.usedJSHeapSize / 1048576) + ' MB';
                }
                frameCount = 0; lastFpsUpdate = now;
            }
            lastFrameTime = now;
        }

        function setTheme(theme) {
            currentTheme = theme;
            document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
            const themes = ['default', 'fire', 'ice', 'matrix', 'cyber'];
            document.querySelectorAll('.theme-btn')[themes.indexOf(theme)].classList.add('active');

            const color = new THREE.Color();
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const ratio = i / PARTICLE_COUNT;
                if (theme === 'default') color.setHSL(0.5 + ratio * 0.2, 0.8, 0.6);
                else if (theme === 'fire') color.setHSL(0.0 + ratio * 0.15, 1.0, 0.5);
                else if (theme === 'ice') color.setHSL(0.5 + ratio * 0.1, 0.8, 0.5 + ratio*0.4);
                else if (theme === 'matrix') color.setRGB(0.1, 0.5 + Math.random()*0.5, 0.1);
                else if (theme === 'cyber') color.setHSL(0.8 + ratio * 0.2, 1.0, 0.6);
                
                targetColors[i3] = color.r; targetColors[i3+1] = color.g; targetColors[i3+2] = color.b;
            }
        }

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const gr = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gr.addColorStop(0, 'rgba(255,255,255,1)');
            gr.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gr.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gr.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gr; ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        async function generateAIShape() {
            const prompt = document.getElementById('ai-input').value;
            if (!prompt) return;
            const btn = document.getElementById('ai-btn');
            btn.innerText = "Thinking..."; btn.disabled = true;
            try {
                const systemPrompt = `You are a creative coder. The user wants a 3D particle shape described as: "${prompt}". 
                Write a JavaScript code snippet that calculates 'x', 'y', and 'z' coordinates for a single particle.
                Context: Code runs in a loop 'PARTICLE_COUNT' times. Vars: 'i' (index), 'count' (total). Use 'Math'. Scale roughly -15 to 15.
                Output: Return ONLY raw JS code. Assign 'x', 'y', 'z'.`;
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: systemPrompt }] }] })
                });
                const data = await response.json();
                let code = data.candidates[0].content.parts[0].text;
                code = code.replace(/```javascript/g, '').replace(/```/g, '').trim();
                customShapeFunction = new Function('i', 'count', `let x=0,y=0,z=0; ${code} return {x,y,z};`);
                setShape('custom');
                document.getElementById('status').innerText = `Generated: ${prompt}`;
            } catch (error) { console.error(error); document.getElementById('status').innerText = "AI Error."; }
            finally { btn.innerText = "‚ú® Create"; btn.disabled = false; }
        }

        function calculateTargets(shape) {
            currentShape = shape;
            if(isFluidActive) toggleFluid();
            let x, y, z;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                if (shape === 'custom' && customShapeFunction) {
                    try { const res = customShapeFunction(i, PARTICLE_COUNT); x=res.x; y=res.y; z=res.z; } catch(e) { x=(Math.random()-0.5)*10; y=(Math.random()-0.5)*10; z=(Math.random()-0.5)*10; }
                } else if (shape === 'sphere') {
                    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    x = 12 * Math.cos(theta) * Math.sin(phi); y = 12 * Math.sin(theta) * Math.sin(phi); z = 12 * Math.cos(phi);
                } else if (shape === 'heart') {
                    const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                    x = 9.6 * Math.pow(Math.sin(t), 3);
                    y = 0.6 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    z = (Math.random() - 0.5) * 8; 
                } else if (shape === 'saturn') {
                     const ratio = i / PARTICLE_COUNT;
                     if (ratio < 0.4) {
                         const phi = Math.acos(-1 + (2 * (i/(PARTICLE_COUNT*0.4))));
                         const theta = Math.sqrt((PARTICLE_COUNT*0.4) * Math.PI) * phi;
                         x = 6 * Math.cos(theta) * Math.sin(phi); y = 6 * Math.sin(theta) * Math.sin(phi); z = 6 * Math.cos(phi);
                     } else {
                         const theta = Math.random() * Math.PI * 2;
                         const r = 9 + Math.random() * 6;
                         x = r * Math.cos(theta); z = r * Math.sin(theta); y = (Math.random()-0.5)*0.5;
                         const tempY = y; y = y * Math.cos(0.4) - z * Math.sin(0.4); z = tempY * Math.sin(0.4) + z * Math.cos(0.4);
                     }
                } else if (shape === 'helix') {
                    const t = i * 0.1; x = Math.cos(t) * 5; z = Math.sin(t) * 5; y = (i * 0.05) - 20; 
                }
                targets[i3] = x; targets[i3+1] = y; targets[i3+2] = z;
            }
        }

        function setShape(shapeName) {
            calculateTargets(shapeName);
            document.querySelectorAll('.btn').forEach(btn => {
                if(!btn.id.startsWith('btn-') && btn.id !== 'ai-btn' && !btn.id.startsWith('vis-')) btn.classList.remove('active');
            });
            if(shapeName !== 'custom') {
                 const buttons = document.querySelectorAll('.btn');
                 buttons.forEach(b => { if(b.getAttribute('onclick')?.includes(shapeName)) b.classList.add('active'); });
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        async function setupWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    [motionCanvas, trackingCanvas, skeletonCanvas, radarCanvas, confidenceCanvas].forEach(c => { c.width = HUD_WIDTH; c.height = HUD_HEIGHT; });
                    isWebcamReady = true;
                };
            } catch (err) { document.getElementById('status').innerText = "Camera Access Denied"; }
        }

        function setupMediaPipe() {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onHandResults);
            
            async function send() {
                if (video.readyState === 4) {
                    await hands.send({image: video});
                }
                requestAnimationFrame(send);
            }
            send();
        }

        function onHandResults(results) {
            handResults = results;
            skeletonCtx.clearRect(0, 0, HUD_WIDTH, HUD_HEIGHT);
            activeHandCount = 0;
            
            // Confidence Canvas Reset
            confidenceCtx.clearRect(0, 0, HUD_WIDTH, HUD_HEIGHT);
            confidenceCtx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            confidenceCtx.fillRect(0,0,HUD_WIDTH,HUD_HEIGHT); // BG

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const handsFound = Math.min(results.multiHandLandmarks.length, 2);
                activeHandCount = handsFound;
                let displayText = `Hands: ${handsFound} | `;
                
                for(let i=0; i<handsFound; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    drawConnectors(skeletonCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 1});
                    drawLandmarks(skeletonCtx, landmarks, {color: '#FF0000', lineWidth: 0.5, radius: 2});
                    
                    // Detect & Calculate confidence
                    detectGesture(landmarks, i);
                    handGestures[i] = gestureConfidence[i].name;
                    
                    displayText += `H${i+1}: ${handGestures[i].toUpperCase()} `;
                    updatePointer(1 - landmarks[9].x, 1 - landmarks[9].y, i);
                    
                    // Draw Bars
                    drawConfidenceBars(i);
                }
                
                // Double Pinch Logic Checks
                const isDoublePinch = (handsFound === 2 && handGestures[0] === 'pinch' && handGestures[1] === 'pinch');

                if (handsFound === 2) {
                    const dist = pointers[0].distanceTo(pointers[1]);
                    
                    // Only Zoom if NOT double pinching (Double pinch = Color Shift Mode)
                    if (!isDoublePinch) {
                        if (previousHandDist > 0) {
                            shapeScale += (dist - previousHandDist) * 0.1;
                            shapeScale = Math.max(0.2, Math.min(shapeScale, 3.0));
                        }
                        displayText += `| Scale: ${shapeScale.toFixed(2)}`;
                    } else {
                        displayText += `| MODE: COLOR SHIFT`;
                    }
                    previousHandDist = dist;
                } else {
                    previousHandDist = 0;
                    shapeScale += (1.0 - shapeScale) * 0.05;
                }
                document.getElementById('status').innerText = displayText;
            } else {
                document.getElementById('status').innerText = "Wave hands to interact...";
                shapeScale += (1.0 - shapeScale) * 0.05;
                if (isWebcamReady) processPixelMotion();
            }
            
            // Draw Radar
            drawRadar();
        }

        function drawConfidenceBars(handIndex) {
            // Larger canvas means we can draw bigger bars
            const w = 90;
            const x = handIndex * 110 + 10;
            const yBase = 160;
            const conf = gestureConfidence[handIndex].scores;
            
            confidenceCtx.fillStyle = 'white';
            confidenceCtx.font = '12px Courier New';
            confidenceCtx.fillText(`Hand ${handIndex+1}: ${gestureConfidence[handIndex].name}`, x, 20);

            const gestures = ['Open', 'Fist', 'Victory', 'Pinch'];
            gestures.forEach((g, idx) => {
                let val = conf[g] || 0.1;
                
                // Color based on active state
                if (g.toLowerCase() === gestureConfidence[handIndex].name) confidenceCtx.fillStyle = 'rgba(0, 255, 150, 0.8)';
                else confidenceCtx.fillStyle = 'rgba(200, 0, 255, 0.4)';
                
                confidenceCtx.fillRect(x, yBase - (idx * 28), w * val, 18);
                confidenceCtx.fillStyle = 'rgba(255,255,255,0.8)';
                confidenceCtx.fillText(g, x + 2, yBase - (idx * 28) + 12);
            });
        }

        function drawRadar() {
            // Advanced Sci-Fi Radar
            const cx = HUD_WIDTH / 2;
            const cy = HUD_HEIGHT / 2;
            const maxDist = HUD_HEIGHT / 2 - 5;
            const scale = 3.0; // World to Radar Scale

            // 1. Clear & Dark Background
            radarCtx.fillStyle = 'rgba(0, 10, 20, 0.85)';
            radarCtx.fillRect(0, 0, HUD_WIDTH, HUD_HEIGHT);
            
            // 2. Grid Rings (Concentric circles)
            radarCtx.strokeStyle = 'rgba(0, 255, 200, 0.15)';
            radarCtx.lineWidth = 1;
            for (let r = 20; r < maxDist; r += 20) {
                radarCtx.beginPath();
                radarCtx.arc(cx, cy, r, 0, Math.PI * 2);
                radarCtx.stroke();
            }
            
            // 3. Crosshairs
            radarCtx.strokeStyle = 'rgba(0, 255, 200, 0.3)';
            radarCtx.beginPath();
            radarCtx.moveTo(cx, 0); radarCtx.lineTo(cx, HUD_HEIGHT);
            radarCtx.moveTo(0, cy); radarCtx.lineTo(HUD_WIDTH, cy);
            radarCtx.stroke();

            // 4. Scanner Sweep Line
            radarSweepAngle = (Date.now() * 0.003) % (Math.PI * 2);
            radarCtx.save();
            radarCtx.translate(cx, cy);
            radarCtx.rotate(radarSweepAngle);
            
            // Sweep gradient
            const grad = radarCtx.createLinearGradient(0, 0, maxDist, 0);
            grad.addColorStop(0, 'rgba(0, 255, 150, 0)');
            grad.addColorStop(1, 'rgba(0, 255, 150, 0.3)');
            radarCtx.fillStyle = grad;
            
            radarCtx.beginPath();
            radarCtx.moveTo(0, 0);
            radarCtx.arc(0, 0, maxDist, -0.15, 0.15); // Wedge shape
            radarCtx.fill();
            radarCtx.restore();

            // 5. Camera Position (Yellow Triangle at bottom)
            // Camera Z is +30. In Top-Down (XZ), +Z is "down" on screen.
            radarCtx.fillStyle = '#ffff00';
            radarCtx.beginPath();
            radarCtx.moveTo(cx, HUD_HEIGHT - 2);
            radarCtx.lineTo(cx - 5, HUD_HEIGHT - 10);
            radarCtx.lineTo(cx + 5, HUD_HEIGHT - 10);
            radarCtx.fill();

            // 6. Particles (Depth Coded)
            // Sample every 20th particle for performance
            for(let i=0; i<PARTICLE_COUNT; i+=20) {
                const px = cx + (positions[i*3] * scale);
                const pz = cy + (positions[i*3+2] * scale); 
                const py = positions[i*3+1]; // Height
                
                // Depth cue: Higher (Y > 0) = Brighter/Larger
                // Range approx -15 to 15
                const intensity = Math.max(0.2, Math.min(1.0, (py + 15) / 30));
                const size = intensity * 1.5;
                
                radarCtx.fillStyle = `rgba(100, 200, 255, ${intensity})`;
                radarCtx.fillRect(px - size/2, pz - size/2, size, size);
            }
            
            // 7. Floating Objects (Orange Squares)
            if (isObjectsActive) {
                radarCtx.strokeStyle = '#ffaa00';
                radarCtx.lineWidth = 2;
                floatingObjects.forEach(obj => {
                     const px = cx + (obj.mesh.position.x * scale);
                     const pz = cy + (obj.mesh.position.z * scale);
                     radarCtx.strokeRect(px-3, pz-3, 6, 6);
                });
            }

            // 8. Hands (Red Pulsing Dots)
            for(let i=0; i<activeHandCount; i++) {
                const px = cx + (pointers[i].x * scale);
                const pz = cy + (pointers[i].z * scale);
                
                // Pulse animation
                const pulse = (Math.sin(Date.now() * 0.015) + 1) * 3;
                
                radarCtx.fillStyle = '#ff3333';
                radarCtx.beginPath();
                radarCtx.arc(px, pz, 3, 0, Math.PI*2);
                radarCtx.fill();
                
                radarCtx.strokeStyle = `rgba(255, 50, 50, ${1 - pulse/7})`;
                radarCtx.beginPath();
                radarCtx.arc(px, pz, 3 + pulse, 0, Math.PI*2);
                radarCtx.stroke();
                
                radarCtx.fillStyle = '#fff';
                radarCtx.font = '10px Arial';
                radarCtx.fillText(`H${i+1}`, px + 6, pz);
            }
        }

        function updatePointer(x, y, index) {
             const vector = new THREE.Vector3((x * 2) - 1, (y * 2) - 1, 0.5);
             vector.unproject(camera);
             const dir = vector.sub(camera.position).normalize();
             const pos = camera.position.clone().add(dir.multiplyScalar(-camera.position.z/dir.z));
             pointers[index].lerp(pos, 0.3);
        }

        function detectGesture(landmarks, index) {
            const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            const wrist = landmarks[0];
            
            // Pinch: Thumb Tip to Index Tip
            const pinchDist = dist(landmarks[4], landmarks[8]);
            
            // Fist: Average distance of tips to wrist
            let avgTipDist = 0;
            [8,12,16,20].forEach(i => avgTipDist += dist(landmarks[i], wrist));
            avgTipDist /= 4;

            // Victory: Extension checks relative to wrist
            const indexDist = dist(landmarks[8], wrist);
            const midDist = dist(landmarks[12], wrist);
            const ringDist = dist(landmarks[16], wrist);
            
            // --- Confidence Calculation (Approximation) ---
            // Normalize values to 0-1 range for bar display
            // Lower distance = Higher confidence for Pinch/Fist
            
            const pinchConf = Math.max(0, 1 - (pinchDist / 0.15)); // Threshold ~0.15
            const fistConf = Math.max(0, 1 - (avgTipDist / 0.4));  // Threshold ~0.4
            
            // Victory is harder to quantify continuously, approximated by Index+Mid extension vs Ring flexion
            // (Index + Mid) - (Ring) scaled
            const victoryRaw = (indexDist + midDist) - (ringDist * 2);
            const victoryConf = Math.max(0, Math.min(1, victoryRaw + 0.2)); 
            
            // Open is default/fallback
            const openConf = Math.max(0, Math.min(1, (avgTipDist - 0.3) * 2)); 

            // Determine winner
            let name = 'open';
            const mesh = cursorMeshes[index];
            if (mesh) {
                if (pinchConf > 0.7) {
                    name = 'pinch'; mesh.material.color.setHex(0xffff00);
                } else if (victoryConf > 0.6) {
                    name = 'victory'; mesh.material.color.setHex(0x00ffff);
                } else if (fistConf > 0.6) {
                    name = 'fist'; mesh.material.color.setHex(0xaa00ff);
                } else {
                    name = 'open'; mesh.material.color.setHex(0xff3333);
                }
            }

            // Store for UI
            gestureConfidence[index] = {
                name: name,
                scores: {
                    'Pinch': pinchConf,
                    'Fist': fistConf,
                    'Victory': victoryConf,
                    'Open': openConf
                }
            };
        }

        function processPixelMotion() {
            motionCtx.drawImage(video, 0, 0, motionCanvas.width, motionCanvas.height);
            const frame = motionCtx.getImageData(0, 0, motionCanvas.width, motionCanvas.height);
            const data = frame.data;
            trackingCtx.fillStyle = 'rgba(0, 20, 0, 0.3)';
            trackingCtx.fillRect(0, 0, trackingCanvas.width, trackingCanvas.height);
            
            if (!prevFrameData) { prevFrameData = new Uint8ClampedArray(data); return; }
            let sumX = 0, sumY = 0, count = 0;
            trackingCtx.fillStyle = '#00ff96'; 

            for (let i = 0; i < data.length; i += 16) { 
                const diff = Math.abs(data[i+1] - prevFrameData[i+1]);
                if (diff > 20) { 
                    const x = (i/4) % motionCanvas.width;
                    const y = Math.floor((i/4) / motionCanvas.width);
                    trackingCtx.fillRect(x, y, 1, 1);
                    sumX += x; sumY += y; count++;
                }
            }
            prevFrameData.set(data);

            // Increased threshold from 5 to 40 to prevent flickering from camera noise
            if (count > 40) { 
                const avgX = 1 - (sumX / count) / motionCanvas.width; 
                const avgY = 1 - (sumY / count) / motionCanvas.height;
                if(!handResults || handResults.multiHandLandmarks.length === 0) {
                     activeHandCount = 1; 
                     updatePointer(avgX, avgY, 0);
                     handGestures[0] = 'open';
                }
            } else if(!handResults || handResults.multiHandLandmarks.length === 0) {
                 activeHandCount = 0;
            }
        }

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const time = clock.getElapsedTime();
            
            updateStats(now);

            // Track input activity
            if (activeHandCount > 0 || (mouse.x !== 0 || mouse.y !== 0)) {
                lastInputTime = now;
            }

            // Mouse Fallback (If active)
            if (activeHandCount === 0 && (mouse.x !== 0 || mouse.y !== 0)) {
                const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const pos = camera.position.clone().add(dir.multiplyScalar(-camera.position.z/dir.z));
                pointers[0].copy(pos);
                handGestures[0] = 'open';
                activeHandCount = 1;
            }

            // Cursor Visuals & Idle Logic
            // If active, show cursors at pointers
            if (activeHandCount > 0) {
                for(let i=0; i<2; i++) {
                    if (cursorMeshes[i]) {
                        cursorMeshes[i].visible = i < activeHandCount;
                        if(i < activeHandCount) cursorMeshes[i].position.copy(pointers[i]);
                    }
                }
            } 
            // If inactive but recently active (within 1 sec), drift to center (Ideal Place)
            else if (now - lastInputTime < 1000) {
                // Drift pointer 0 to center
                pointers[0].lerp(new THREE.Vector3(0,0,0), 0.1);
                
                if (cursorMeshes[0]) {
                    cursorMeshes[0].visible = true;
                    cursorMeshes[0].position.copy(pointers[0]);
                    cursorMeshes[0].material.color.setHex(0xff3333); // Reset to red
                    cursorMeshes[0].scale.setScalar(1.0);
                }
                if (cursorMeshes[1]) cursorMeshes[1].visible = false;
            } 
            // Completely idle
            else {
                for(let i=0; i<2; i++) if(cursorMeshes[i]) cursorMeshes[i].visible = false;
            }

            // Physics Toy
            if (isToyActive) {
                physicsToyMesh.position.add(toyVelocity);
                physicsToyMesh.rotation.x += 0.05;
                if (Math.abs(physicsToyMesh.position.x) > 25) toyVelocity.x *= -1;
                if (Math.abs(physicsToyMesh.position.y) > 15) toyVelocity.y *= -1;
                if (physicsToyMesh.position.z > 5 || physicsToyMesh.position.z < -10) toyVelocity.z *= -1;
            }

            // --- Interaction Modes ---
            const rotationRef = particles.visible ? particles : (meshCubes.visible ? meshCubes : meshShards);
            const isDoublePinch = (activeHandCount === 2 && handGestures[0] === 'pinch' && handGestures[1] === 'pinch');

            if (!isFluidActive) {
                if (isDoublePinch) {
                    // --- DOUBLE PINCH MODE: Lock Rotation & Shift Color ---
                    
                    // 1. Lock Rotation (Do nothing to rotation)
                    
                    // 2. Color Shift based on Hand 1 Height
                    // Map Y from approx -10 to 10 into Hue offset
                    const handY = pointers[1].y; 
                    const hueShift = (handY + 10) / 20; // 0 to 1 mapping
                    
                    const color = new THREE.Color();
                    for (let i = 0; i < PARTICLE_COUNT; i++) {
                        const i3 = i * 3;
                        const ratio = i / PARTICLE_COUNT;
                        // Dynamic Rainbow shift
                        color.setHSL((ratio * 0.2 + hueShift) % 1.0, 0.8, 0.6);
                        targetColors[i3] = color.r;
                        targetColors[i3+1] = color.g;
                        targetColors[i3+2] = color.b;
                    }

                } else {
                    // --- STANDARD MODE: Rotation & Morphing ---
                    
                    let isManualRot = false;
                    // Only allow rotation if hand 0 is pinching AND NOT holding an object
                    if (activeHandCount === 1 && handGestures[0] === 'pinch' && handGrabbedObj[0] === null) {
                        if (lastPinchPos) {
                             const dx = (pointers[0].x - lastPinchPos.x) * 0.2;
                             const dy = (pointers[0].y - lastPinchPos.y) * 0.2;
                             particles.rotation.y += dx; particles.rotation.x -= dy;
                             meshCubes.rotation.y += dx; meshCubes.rotation.x -= dy;
                             meshShards.rotation.y += dx; meshShards.rotation.x -= dy;
                             isManualRot = true;
                        }
                        lastPinchPos = pointers[0].clone();
                    } else { lastPinchPos = null; }
                    
                    if (!isManualRot) {
                         const ry = 0.0015;
                         particles.rotation.y += ry; particles.rotation.x *= 0.95;
                         meshCubes.rotation.y += ry; meshCubes.rotation.x *= 0.95;
                         meshShards.rotation.y += ry; meshShards.rotation.x *= 0.95;
                    }
                }
                
                particles.updateMatrixWorld();
                meshCubes.updateMatrixWorld();
                meshShards.updateMatrixWorld();

            } else if (isFluidActive) {
                particles.rotation.set(0,0,0); meshCubes.rotation.set(0,0,0); meshShards.rotation.set(0,0,0);
                particles.updateMatrixWorld(); meshCubes.updateMatrixWorld(); meshShards.updateMatrixWorld();
            }

            const localPointers = [];
            let localToyPos = null;
            if (particles) {
                const invMat = new THREE.Matrix4().copy(particles.matrixWorld).invert();
                for(let i=0; i<activeHandCount; i++) if (pointers[i]) localPointers[i] = pointers[i].clone().applyMatrix4(invMat);
                if (isToyActive) localToyPos = physicsToyMesh.position.clone().applyMatrix4(invMat);
            }

            if (isObjectsActive) {
                floatingObjects.forEach((obj, idx) => {
                    // Grab Logic
                    let isGrabbed = false;
                    
                    // Check if already grabbed
                    if (handGrabbedObj[0] === idx || handGrabbedObj[1] === idx) {
                        isGrabbed = true;
                        const handIdx = handGrabbedObj[0] === idx ? 0 : 1;
                        const handPos = localPointers[handIdx];
                        
                        // If grab released (gesture changed)
                        if (handGestures[handIdx] !== 'pinch') {
                            handGrabbedObj[handIdx] = null;
                            isGrabbed = false;
                        } else if (handPos) {
                            obj.velocity.subVectors(handPos, obj.mesh.position).multiplyScalar(0.2); 
                            obj.mesh.position.copy(handPos);
                        }
                    } else {
                        // Check for new grab
                        for(let h=0; h<activeHandCount; h++) {
                            // Don't grab if we are in Double Pinch Mode (Color Shift)
                            if (!isDoublePinch && handGestures[h] === 'pinch' && handGrabbedObj[h] === null && localPointers[h]) {
                                const dist = obj.mesh.position.distanceTo(localPointers[h]);
                                if (dist < 4.0) {
                                    handGrabbedObj[h] = idx;
                                    isGrabbed = true;
                                }
                            }
                        }
                    }

                    if (!isGrabbed) {
                        obj.mesh.position.add(obj.velocity);
                        obj.mesh.rotation.x += obj.rotVel.x;
                        obj.mesh.rotation.y += obj.rotVel.y;
                        if(obj.mesh.position.x > 30 || obj.mesh.position.x < -30) obj.velocity.x *= -1;
                        if(obj.mesh.position.y > 20 || obj.mesh.position.y < -20) obj.velocity.y *= -1;
                        if(obj.mesh.position.z > 15 || obj.mesh.position.z < -15) obj.velocity.z *= -1;
                    }
                });
            }

            const posAttr = geometry.attributes.position;
            const colAttr = geometry.attributes.color;
            const colorHelper = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let px = posAttr.array[i3];
                let py = posAttr.array[i3 + 1];
                let pz = posAttr.array[i3 + 2];
                let vx = velocities[i3];
                let vy = velocities[i3+1];
                let vz = velocities[i3+2];

                if (isFluidActive) {
                    vx *= 0.95; vy *= 0.95; vz *= 0.95;
                    for(let h=0; h<activeHandCount; h++) {
                        if (!localPointers[h]) continue;
                        const dx = px - localPointers[h].x;
                        const dy = py - localPointers[h].y;
                        const dz = pz - localPointers[h].z;
                        const dSq = dx*dx + dy*dy + dz*dz;
                        if(dSq < 60) {
                            const f = (60 - dSq) * 0.001;
                            vx += dx * f; vy += dy * f; vz += dz * f;
                        }
                    }
                    const timeS = time * 0.5;
                    vx += Math.sin(py * 0.1 + timeS) * 0.02;
                    vy += Math.cos(px * 0.1 + timeS) * 0.02;
                    
                    px += vx; py += vy; pz += vz;
                    if(px > 30) px = -30; if(px < -30) px = 30;
                    if(py > 20) py = -20; if(py < -20) py = 20;
                    if(pz > 15) pz = -15; if(pz < -15) pz = 15;
                    velocities[i3] = vx; velocities[i3+1] = vy; velocities[i3+2] = vz;
                } else {
                    const tx = targets[i3] * shapeScale;
                    const ty = targets[i3+1] * shapeScale;
                    const tz = targets[i3+2] * shapeScale;
                    
                    // Don't freeze morphing if we are grabbing objects or doing color shift
                    // Only freeze morphing for rotation (single pinch empty)
                    const isMorphFrozen = (activeHandCount === 1 && handGestures[0] === 'pinch' && handGrabbedObj[0] === null);

                    if (!isMorphFrozen) { 
                        px += (tx - px) * 0.05;
                        py += (ty - py) * 0.05;
                        pz += (tz - pz) * 0.05;
                    }

                    for(let h=0; h<activeHandCount; h++) {
                        if (!localPointers[h]) continue;
                        const dx = px - localPointers[h].x;
                        const dy = py - localPointers[h].y;
                        const dz = pz - localPointers[h].z;
                        const dSq = dx*dx + dy*dy + dz*dz;
                        
                        if (dSq < 30) {
                            const dist = Math.sqrt(dSq);
                            let force = (30 - dSq) / 30;
                            if (handGestures[h] === 'fist') force *= -2.0;
                            else if (handGestures[h] === 'victory') {
                                px += -dy * 0.2 * force;
                                py += dx * 0.2 * force;
                                force *= -0.05; 
                            } else if (handGestures[h] !== 'pinch') {
                                force *= 0.5; 
                            } else force = 0;

                            px += dx * force * 0.1;
                            py += dy * force * 0.1;
                            pz += dz * force * 0.1;
                        }
                    }
                }

                if (isObjectsActive) {
                    floatingObjects.forEach(obj => {
                        const tdx = px - obj.mesh.position.x;
                        const tdy = py - obj.mesh.position.y;
                        const tdz = pz - obj.mesh.position.z;
                        const tdSq = tdx*tdx + tdy*tdy + tdz*tdz;
                        
                        if (tdSq < 25) { 
                            const tf = (25 - tdSq) / 25 * 0.3;
                            px += tdx * tf; py += tdy * tf; pz += tdz * tf;
                        }
                    });
                }

                posAttr.array[i3] = px;
                posAttr.array[i3+1] = py;
                posAttr.array[i3+2] = pz;

                colAttr.array[i3] += (targetColors[i3] - colAttr.array[i3]) * 0.05;
                colAttr.array[i3+1] += (targetColors[i3+1] - colAttr.array[i3+1]) * 0.05;
                colAttr.array[i3+2] += (targetColors[i3+2] - colAttr.array[i3+2]) * 0.05;

                if (currentVisual !== 'points') {
                    dummy.position.set(px, py, pz);
                    dummy.rotation.set(time + i, time + i*0.5, 0); 
                    dummy.scale.setScalar(1); 
                    dummy.updateMatrix();
                    const activeMesh = (currentVisual === 'cubes') ? meshCubes : meshShards;
                    activeMesh.setMatrixAt(i, dummy.matrix);
                    colorHelper.setRGB(colAttr.array[i3], colAttr.array[i3+1], colAttr.array[i3+2]);
                    activeMesh.setColorAt(i, colorHelper);
                }
            }

            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;
            
            if (currentVisual === 'cubes') {
                meshCubes.instanceMatrix.needsUpdate = true;
                meshCubes.instanceColor.needsUpdate = true;
            } else if (currentVisual === 'shards') {
                meshShards.instanceMatrix.needsUpdate = true;
                meshShards.instanceColor.needsUpdate = true;
            }

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>